# Optimizely Content Cloud Webhooks

This is an add-on for Optimizely Content Cloud that allows for webhook functionality -- content operations can generate HTTP requests to external resources.

Some features (of the default implementation):

* Posts a JSON-serialized version of the content involved in the operation
* Generates a webhook for four content actions: (1) published, (2) moved, (3) trashed (moved to the wastebasket), and (4) deleted
* Operates in a separate thread. It will not block the UI, and any failures will not affect the Content Cloud installation
* Will queue infinite webhooks in a thread-safe worker environment. A separate thread works webhooks in the queue, and multiple threads can be started to work the queue.
* Allows for a specific number of retries after a specified retry delay ("if this webhook call fails, retry five more times, once every 15 seconds")
* Allows for throttling per thread ("each thread should only make one webhook call per second")
* Saves a history of each webhook execution, including multiple attempts in the event of failure

It is designed to be extended:

* The core logic a series of injected services which can be replaced as needed
* Replaceable services handle low-level operations such as:
   * Determination of whether the webhook should execute or cancel
   * Determination of the webhook URL target
   * Serialization of the content and manipulation of the body, URL, and headers of the web request
   * Persistence of the webhook history to a data store
* The default implementations of all services are designed to be inherited -- nothing is `final` or `sealed` and very little is `private`. Methods have been kept small, with liberal `protected` helper functions -- overriding the main method in a derived class doesn't hide all the helper code.

## The Components

### IWebhookManager

This exposes the event handlers that Content Cloud calls when events are raised, and manages and works the queue of pending webhooks.

By default, event handlers are attached to:

* `ContentPublished`
* `ContentMoved`
* `ContentDeleted`

Note that `ContentMoved` covers "soft deletes" as well, since those are technically just moves to the wastebasket.

The event handlers will create an `Webhook` object, populating target URL (via the `IWebhookRouter`), and place the webhook in the queue.

When the default `WebhookManager` is created, a separate thread is launched to watch the queue. It retrieves a webhook, creates a web request via the `IWebhookSerializer`, then executes it via the `IWebhookHttpProcessor` and stores the result. If the webhook fails, it might be abandoned or placed back in queue after a delay, depending on the retry settings.

### Webhook and WebhookAttempt

This represents a single webhook generated from an event. A webhook contains the following information:

* The target URL it will call (generated by `IWebhookRouter`)
* The content object that generated the webhook
* A string representing the action that generated it ("Published", "Deleted", etc.)

Webhooks are placed in the `IWebhookMaster` queue, and are worked serially.

A `Webhook` will generate a HTTP request when it is executed, and the results of that will be placed in its `History` property. If the HTTP request fails (returns any status code other than 200), the webhook might be retried several times. Each time will generate another `WebhookAttempt` record.

Once a `Webhook` has succeeded (the last `WebhookAttempt` in its `History` was successful), it will never execute again. Future content operations on the same content object will create a new `Webhook` object.

### IWebhookRouter

This determines two things:

1. Should the webhook execute at all?
2. What URL should the webhook target?

The interface contains one method: `Route` which returns a `Uri`. The default implementation simply returns the setting of `WebhookMaster.Target` in all cases.

You can re-implement and return whatever URL you need based on the content, the operation, or any other criteria.

If you want to cancel a webhook altogether, return `null`. The webhook won't be placed in queue and will eventually be garbage collected.

### IWebhookSerializer

This turns a webhook into an `HttpWebRequest`.

The default implementation creates a POST request to the webhook target (which was populated by `IWebhookRouter`) with a JSON-serialized version of the content as the body of the request, and the `Action` as a querystring argument.

A helper class is provided to make it easier to create requests.

### IWebhookHttpProcessor

This simply executes the `HttpWebRequest` created by `IwebhookSerializer`.

It's injected mainly so you can mock the HTTP request for testing.

The default implementation simply executes and returns a `WebhookAttempt` to be placed into history. Another implementation is provided which mocks a unstable receiver -- it fails a specified number of times before succeeding.

### IWebhookStore

This persists the webhook. It's called when the webhook is placed in queue, and after every attempt to execute it (each attempt will append a `WebhookAttempt` record to it).

Two default implementations are provided: one writes JSON to the file system, the other just holds the webhooks in memory.

When a UI is created, more methods will be created for this which will allow listing and searching the webhooks.

## Basic Flow

This is the basic flow. A lot of this is dependent on the default implementation of services. If you inject your own implementation, things could be different.

1. Your app starts up, and `WebhooksInit`:
   * Injects all the services as singletons
   * Binds the event handlers
1. A content operation occurs in Content Cloud and an event is raised
3. The event handler on `IWebhookManager`:
   * Creates a `Webhook` object
   * Populates a URL target from `IWebhookRouter`
   * Puts it in the queue (assuming a URL was returned from `IWebhookRouter`; if `null` was returned, the webhook is abandoned)
   * Passes it to `IWebhookStore` to persist it
4. The `Webhook` object is found in the queue by the worker thread
5. The worker thread passes the webhook to `IWebhookSerializer` and gets an `HttpWebRequest` back
6. The worker thread passes the `HttpWebRequest` to `IWebhookHttpProcessor` and gets back a `WebhookAttempt`
7. The worker thread attaches the `WebhookAttempt` to the history of `Webhook`
8. The worker thread passes the `Webhook` to `IWebhookStore` to persist it
   * If the webhook execution succeeded, we're all done 
   * If the webhook execution failed, the worker thread might set a timer for the default retry delay, then place the `Webhook` back in the queue (this depends on the settings)
10. The worker thread waits the specified throttle time delay, then waits for a new object in the queue

## To Install and Configure

Compile the code into your project.

Somewhere in your startup code, set the static `WebhookManager.Target` property to your webhook target.

(If you don't do this, the event handlers will execute, but `WebhookRouter` will return `null` so no webhooks will queue. This is effectively a "switch" to turn webhooks on and off.)

On `WebhookManager`, you can set the following static properties:

* `MaxAttempts` (default: 5): The maximum number of times a webhook should execute. If it fails on every attempt, it will abandon
* `DelayBetweenRetries` (default: 10 seconds): The number of milliseconds the worker should wait before putting a failed webhook back in queue
* `Throttle` (default: 1 second): The number of milliseconds each worker thread should wait before retrieving a new webhook from the queue

By default, `WebhookManager` will create one worker thread. If you desire more, you can call `WebhookManager.StartWatcher(int count)` and start as many as you like. The queue is thread-safe, but you will increase load on your endpoint.

By default, webhooks are persisted to memory. If you want to persist them to the file system, change the `IWebhookStore` service injection to use `FileSystemWebhookStore` and set the `FileSystemWebhookStore.StorePath` static property.

## To Inject Your Own Services

If you re-implement any services, they must be injected _after_ `WebhooksInit` has run, or they will be over-written. To do this, put a `ModuleDependency` on your initialization code:

```
[InitializableModule]
[ModuleDependency(typeof(WebhooksInit))]
public class MyWebhooksInit : IConfigurableModule
{
    public void ConfigureContainer(ServiceConfigurationContext context)
    {
        context.Services.AddSingleton<IWebhookRouter, MyWebhookRouter>();
    }

    public void Initialize(InitializationEngine context) { }

    public void Uninitialize(InitializationEngine context) { }
}
```

This will wait until `WebhooksInit` has executed, then overwrite *those* services with your own implementations.